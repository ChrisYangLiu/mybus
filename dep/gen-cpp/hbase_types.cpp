/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hbase_types.h"

#include <algorithm>

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 {

int _kTDeleteTypeValues[] = {
  TDeleteType::DELETE_COLUMN,
  TDeleteType::DELETE_COLUMNS
};
const char* _kTDeleteTypeNames[] = {
  "DELETE_COLUMN",
  "DELETE_COLUMNS"
};
const std::map<int, const char*> _TDeleteType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTDeleteTypeValues, _kTDeleteTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TTimeRange::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TTimeRange::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_minStamp = false;
  bool isset_maxStamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minStamp);
          isset_minStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxStamp);
          isset_maxStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_minStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TTimeRange");

  xfer += oprot->writeFieldBegin("minStamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->maxStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTimeRange &a, TTimeRange &b) {
  using ::std::swap;
  swap(a.minStamp, b.minStamp);
  swap(a.maxStamp, b.maxStamp);
}

const char* TColumn::ascii_fingerprint = "354B89A42CE318BBBCE588A386D5D6CD";
const uint8_t TColumn::binary_fingerprint[16] = {0x35,0x4B,0x89,0xA4,0x2C,0xE3,0x18,0xBB,0xBC,0xE5,0x88,0xA3,0x86,0xD5,0xD6,0xCD};

uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          this->__isset.qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.qualifier) {
    xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->qualifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

const char* TColumnValue::ascii_fingerprint = "1B53D3FAC5A5CFD45E7E867DA6314FAB";
const uint8_t TColumnValue::binary_fingerprint[16] = {0x1B,0x53,0xD3,0xFA,0xC5,0xA5,0xCF,0xD4,0x5E,0x7E,0x86,0x7D,0xA6,0x31,0x4F,0xAB};

uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TColumnValue");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

const char* TColumnIncrement::ascii_fingerprint = "C55F1CDA80E5E1836AFA7E590331D0A5";
const uint8_t TColumnIncrement::binary_fingerprint[16] = {0xC5,0x5F,0x1C,0xDA,0x80,0xE5,0xE1,0x83,0x6A,0xFA,0x7E,0x59,0x03,0x31,0xD0,0xA5};

uint32_t TColumnIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TColumnIncrement");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amount) {
    xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->amount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnIncrement &a, TColumnIncrement &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

const char* TResult::ascii_fingerprint = "FBE20C68200F7AC71F9527445D887F19";
const uint8_t TResult::binary_fingerprint[16] = {0xFB,0xE2,0x0C,0x68,0x20,0x0F,0x7A,0xC7,0x1F,0x95,0x27,0x44,0x5D,0x88,0x7F,0x19};

uint32_t TResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->columnValues.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->columnValues[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TResult");

  if (this->__isset.row) {
    xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->row);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter5;
    for (_iter5 = this->columnValues.begin(); _iter5 != this->columnValues.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResult &a, TResult &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.__isset, b.__isset);
}

const char* TGet::ascii_fingerprint = "9967209EC61F62E1A2DB77EAC9ED2D6D";
const uint8_t TGet::binary_fingerprint[16] = {0x99,0x67,0x20,0x9E,0xC6,0x1F,0x62,0xE1,0xA2,0xDB,0x77,0xEA,0xC9,0xED,0x2D,0x6D};

uint32_t TGet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->columns.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->columns[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              std::string _key16;
              xfer += iprot->readBinary(_key16);
              std::string& _val17 = this->attributes[_key16];
              xfer += iprot->readBinary(_val17);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TGet");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter18;
      for (_iter18 = this->columns.begin(); _iter18 != this->columns.end(); ++_iter18)
      {
        xfer += (*_iter18).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter19;
      for (_iter19 = this->attributes.begin(); _iter19 != this->attributes.end(); ++_iter19)
      {
        xfer += oprot->writeBinary(_iter19->first);
        xfer += oprot->writeBinary(_iter19->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGet &a, TGet &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.timeRange, b.timeRange);
  swap(a.maxVersions, b.maxVersions);
  swap(a.filterString, b.filterString);
  swap(a.attributes, b.attributes);
  swap(a.__isset, b.__isset);
}

const char* TPut::ascii_fingerprint = "A055A72DCE4D0FAEBB884E5E6730D964";
const uint8_t TPut::binary_fingerprint[16] = {0xA0,0x55,0xA7,0x2D,0xCE,0x4D,0x0F,0xAE,0xBB,0x88,0x4E,0x5E,0x67,0x30,0xD9,0x64};

uint32_t TPut::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->columnValues.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->columnValues[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->writeToWal);
          this->__isset.writeToWal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _ktype26;
            ::apache::thrift::protocol::TType _vtype27;
            xfer += iprot->readMapBegin(_ktype26, _vtype27, _size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              std::string _key30;
              xfer += iprot->readBinary(_key30);
              std::string& _val31 = this->attributes[_key30];
              xfer += iprot->readBinary(_val31);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TPut");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter32;
    for (_iter32 = this->columnValues.begin(); _iter32 != this->columnValues.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeToWal) {
    xfer += oprot->writeFieldBegin("writeToWal", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->writeToWal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter33;
      for (_iter33 = this->attributes.begin(); _iter33 != this->attributes.end(); ++_iter33)
      {
        xfer += oprot->writeBinary(_iter33->first);
        xfer += oprot->writeBinary(_iter33->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPut &a, TPut &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.timestamp, b.timestamp);
  swap(a.writeToWal, b.writeToWal);
  swap(a.attributes, b.attributes);
  swap(a.__isset, b.__isset);
}

const char* TDelete::ascii_fingerprint = "B23CAB9FE9B4EAB3ACAA808A3B9FBAD8";
const uint8_t TDelete::binary_fingerprint[16] = {0xB2,0x3C,0xAB,0x9F,0xE9,0xB4,0xEA,0xB3,0xAC,0xAA,0x80,0x8A,0x3B,0x9F,0xBA,0xD8};

uint32_t TDelete::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->columns.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->columns[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast39;
          xfer += iprot->readI32(ecast39);
          this->deleteType = (TDeleteType::type)ecast39;
          this->__isset.deleteType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->writeToWal);
          this->__isset.writeToWal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _ktype41;
            ::apache::thrift::protocol::TType _vtype42;
            xfer += iprot->readMapBegin(_ktype41, _vtype42, _size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              std::string _key45;
              xfer += iprot->readBinary(_key45);
              std::string& _val46 = this->attributes[_key45];
              xfer += iprot->readBinary(_val46);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDelete::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDelete");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter47;
      for (_iter47 = this->columns.begin(); _iter47 != this->columns.end(); ++_iter47)
      {
        xfer += (*_iter47).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteType) {
    xfer += oprot->writeFieldBegin("deleteType", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->deleteType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeToWal) {
    xfer += oprot->writeFieldBegin("writeToWal", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->writeToWal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter48;
      for (_iter48 = this->attributes.begin(); _iter48 != this->attributes.end(); ++_iter48)
      {
        xfer += oprot->writeBinary(_iter48->first);
        xfer += oprot->writeBinary(_iter48->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDelete &a, TDelete &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.deleteType, b.deleteType);
  swap(a.writeToWal, b.writeToWal);
  swap(a.attributes, b.attributes);
  swap(a.__isset, b.__isset);
}

const char* TIncrement::ascii_fingerprint = "7BA520E95B63B44DBF0A941BCB85069B";
const uint8_t TIncrement::binary_fingerprint[16] = {0x7B,0xA5,0x20,0xE9,0x5B,0x63,0xB4,0x4D,0xBF,0x0A,0x94,0x1B,0xCB,0x85,0x06,0x9B};

uint32_t TIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->columns.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += this->columns[_i53].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->writeToWal);
          this->__isset.writeToWal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TIncrement");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnIncrement> ::const_iterator _iter54;
    for (_iter54 = this->columns.begin(); _iter54 != this->columns.end(); ++_iter54)
    {
      xfer += (*_iter54).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.writeToWal) {
    xfer += oprot->writeFieldBegin("writeToWal", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->writeToWal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIncrement &a, TIncrement &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.writeToWal, b.writeToWal);
  swap(a.__isset, b.__isset);
}

const char* TScan::ascii_fingerprint = "F8E1360E7E23E740DB30C3DEC918736C";
const uint8_t TScan::binary_fingerprint[16] = {0xF8,0xE1,0x36,0x0E,0x7E,0x23,0xE7,0x40,0xDB,0x30,0xC3,0xDE,0xC9,0x18,0x73,0x6C};

uint32_t TScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->stopRow);
          this->__isset.stopRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->columns.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += this->columns[_i59].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->caching);
          this->__isset.caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batchSize);
          this->__isset.batchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _ktype61;
            ::apache::thrift::protocol::TType _vtype62;
            xfer += iprot->readMapBegin(_ktype61, _vtype62, _size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              std::string _key65;
              xfer += iprot->readBinary(_key65);
              std::string& _val66 = this->attributes[_key65];
              xfer += iprot->readBinary(_val66);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TScan");

  if (this->__isset.startRow) {
    xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->startRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stopRow) {
    xfer += oprot->writeFieldBegin("stopRow", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->stopRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter67;
      for (_iter67 = this->columns.begin(); _iter67 != this->columns.end(); ++_iter67)
      {
        xfer += (*_iter67).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.caching) {
    xfer += oprot->writeFieldBegin("caching", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->caching);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchSize) {
    xfer += oprot->writeFieldBegin("batchSize", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->batchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter68;
      for (_iter68 = this->attributes.begin(); _iter68 != this->attributes.end(); ++_iter68)
      {
        xfer += oprot->writeBinary(_iter68->first);
        xfer += oprot->writeBinary(_iter68->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScan &a, TScan &b) {
  using ::std::swap;
  swap(a.startRow, b.startRow);
  swap(a.stopRow, b.stopRow);
  swap(a.columns, b.columns);
  swap(a.caching, b.caching);
  swap(a.maxVersions, b.maxVersions);
  swap(a.timeRange, b.timeRange);
  swap(a.filterString, b.filterString);
  swap(a.batchSize, b.batchSize);
  swap(a.attributes, b.attributes);
  swap(a.__isset, b.__isset);
}

const char* TMutation::ascii_fingerprint = "664520B216BC01A71AA57B370CC3097E";
const uint8_t TMutation::binary_fingerprint[16] = {0x66,0x45,0x20,0xB2,0x16,0xBC,0x01,0xA7,0x1A,0xA5,0x7B,0x37,0x0C,0xC3,0x09,0x7E};

uint32_t TMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->put.read(iprot);
          this->__isset.put = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deleteSingle.read(iprot);
          this->__isset.deleteSingle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TMutation");

  if (this->__isset.put) {
    xfer += oprot->writeFieldBegin("put", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->put.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteSingle) {
    xfer += oprot->writeFieldBegin("deleteSingle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->deleteSingle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMutation &a, TMutation &b) {
  using ::std::swap;
  swap(a.put, b.put);
  swap(a.deleteSingle, b.deleteSingle);
  swap(a.__isset, b.__isset);
}

const char* TRowMutations::ascii_fingerprint = "910BFDE1ABC605DF3A86C76D9D439BD2";
const uint8_t TRowMutations::binary_fingerprint[16] = {0x91,0x0B,0xFD,0xE1,0xAB,0xC6,0x05,0xDF,0x3A,0x86,0xC7,0x6D,0x9D,0x43,0x9B,0xD2};

uint32_t TRowMutations::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_mutations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mutations.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->mutations.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += this->mutations[_i73].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mutations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowMutations::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TRowMutations");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mutations.size()));
    std::vector<TMutation> ::const_iterator _iter74;
    for (_iter74 = this->mutations.begin(); _iter74 != this->mutations.end(); ++_iter74)
    {
      xfer += (*_iter74).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowMutations &a, TRowMutations &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.mutations, b.mutations);
}

const char* TIOError::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TIOError::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TIOError::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIOError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TIOError");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIOError &a, TIOError &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

const char* TIllegalArgument::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TIllegalArgument::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TIllegalArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIllegalArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TIllegalArgument");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIllegalArgument &a, TIllegalArgument &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

}}}} // namespace
